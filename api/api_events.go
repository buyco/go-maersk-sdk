/*
Track & Trace Events

Retrieve Track & Trace Events based on DCSA Interface standard v.2.2  This service provides shippers and consignees visibility to Shipment, Equipment and Transport events for shipments booked with A.P. Moller-Maersk A/S using standards set by the Digital Container Shipping Association.\\ <https://dcsa.org/>

API version: 1.1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

type EventsApi interface {

	/*
		EventsGet Find events.

		Returns all events filtered by the queryParameters.  This endpoint requires **at least one** of the following input parameters:

	* carrierBookingReference
	* transportDocumentReference
	* equipmentReference

	Note:  It is possible to combine queryParameters. When combining queryParameters be aware that it is also possible to make combinations that are mutually contradicting.\
	For example, shipmentEventTypeCode=DRFT and equipmentEventTypeCode=GTIN; since there is no event that can be a ShipmentEvent and an EquipmentEvent at the same time this will return an empty list.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiEventsGetRequest
	*/
	EventsGet(ctx context.Context) ApiEventsGetRequest

	// EventsGetExecute executes the request
	//  @return Events
	EventsGetExecute(r ApiEventsGetRequest) (*Events, *http.Response, error)
}

// EventsApiService EventsApi service
type EventsApiService service

type ApiEventsGetRequest struct {
	ctx                        context.Context
	ApiService                 EventsApi
	carrierBookingReference    *string
	transportDocumentReference *string
	equipmentReference         *string
	eventType                  *[]string
	eventCreatedDateTime       *string
	shipmentEventTypeCode      *[]string
	transportEventTypeCode     *[]string
	equipmentEventTypeCode     *[]string
	limit                      *int32
	cursor                     *string
	aPIVersion                 *string
}

// A set of unique characters provided by carrier to identify a booking. Specifying this filter will only return events related to this particular carrierBookingReference.
func (r ApiEventsGetRequest) CarrierBookingReference(carrierBookingReference string) ApiEventsGetRequest {
	r.carrierBookingReference = &carrierBookingReference
	return r
}

// A unique number reference allocated by the shipping line to the transport document and the main number used for the tracking of the status of the shipment. Specifying this filter will only return events related to this particular transportDocumentReference
func (r ApiEventsGetRequest) TransportDocumentReference(transportDocumentReference string) ApiEventsGetRequest {
	r.transportDocumentReference = &transportDocumentReference
	return r
}

// Will filter by the unique identifier for the equipment, which should follow the BIC ISO Container Identification Number where possible. Specifying this filter will only return events related to this particular equipmentReference
func (r ApiEventsGetRequest) EquipmentReference(equipmentReference string) ApiEventsGetRequest {
	r.equipmentReference = &equipmentReference
	return r
}

// The type of event(s) to filter by. Possible values are - SHIPMENT (Shipment events) - TRANSPORT (Transport events) - EQUIPMENT (Equipment events)  It is possible to select multiple values by comma (,) separating them. For multiple values the OR operator is used. For example, [eventType&#x3D;SHIPMENT,EQUIPMENT] matches both Shipment and Equipment events.\\ Default value is all event types.
func (r ApiEventsGetRequest) EventType(eventType []string) ApiEventsGetRequest {
	r.eventType = &eventType
	return r
}

// Limit the result based on a UTC date. It is possible to use operators on this query parameter. This is done by adding an operator at the beginning of the value followed by a colon:\\ eventCreatedDateTime &#x3D; **gte**:2021-04-01T00:00:00Z\\ would result in all events created &gt;&#x3D; 2021-04-01T00:00:00Z\\ The following operators are supported - gte: (&gt;&#x3D; Greater than or equal) - gt: (&gt; Greater than) - lte: (&lt;&#x3D; Less than or equal) - lt: (&lt; Less than) - eq: (&#x3D; Equal to)  If no operator is provided, a **strictly equal** is used (this is equivalent to **eq:** operator).
func (r ApiEventsGetRequest) EventCreatedDateTime(eventCreatedDateTime string) ApiEventsGetRequest {
	r.eventCreatedDateTime = &eventCreatedDateTime
	return r
}

// The status of the document in the process to filter by. Possible values are - RECE (Received) - DRFT (Drafted) - PENA (Pending Approval) - PENU (Pending Update) - REJE (Rejected) - APPR (Approved) - ISSU (Issued) - SURR (Surrendered) - SUBM (Submitted) - VOID (Void) - CONF (Confirmed) - REQS (Requested) - CMPL (Completed) - HOLD (On Hold) - RELS (Released)  It is possible to select multiple values by comma (,) separating them. For multiple values the OR-operator is used. For example, [shipmentEventTypeCode&#x3D;RECE,DRFT] matches **both** Received (RECE) and Drafted (DRFT) shipment events.\\ Default is all shipmentEventTypeCodes.\\ This filter is only relevant when filtering on ShipmentEvents  **Note: Version 1.1 replaces CONF (Confirmed) for RELS (Released) for documentTypeCode SRM (Shipment Release Message).**
func (r ApiEventsGetRequest) ShipmentEventTypeCode(shipmentEventTypeCode []string) ApiEventsGetRequest {
	r.shipmentEventTypeCode = &shipmentEventTypeCode
	return r
}

// Identifier for type of Transport event to filter by - ARRI (Arrived) - DEPA (Departed)  It is possible to select multiple values by comma (,) separating them. For multiple values the OR operator is used. For example, [transportEventTypeCode&#x3D;ARRI,DEPA} matches **both** Arrived (ARRI) and Departed (DEPA) transport events.\\ Default is all transportEventTypeCodes.\\ This filter is only relevant when filtering on TransportEvents
func (r ApiEventsGetRequest) TransportEventTypeCode(transportEventTypeCode []string) ApiEventsGetRequest {
	r.transportEventTypeCode = &transportEventTypeCode
	return r
}

// Unique identifier for equipmentEventTypeCode. * LOAD (Loaded) * DISC (Discharged) * GTIN (Gated in) * GTOT (Gated out) * STUF (Stuffed) * STRP (Stripped) * PICK (Pick-up) * DROP (Drop-off) * RSEA (Resealed) * RMVD (Removed) * INSP (Inspected)  It is possible to select multiple values by comma (,) separating them. For multiple values the OR operator is used. For example, [equipmentEventTypeCode&#x3D;GTIN,GTOT] matches **both** Gated in (GTIN) and Gated out (GTOT) equipment events.\\ Default is all equipmentEventTypeCodes.\\ This filter is only relevant when filtering on EquipmentEvents
func (r ApiEventsGetRequest) EquipmentEventTypeCode(equipmentEventTypeCode []string) ApiEventsGetRequest {
	r.equipmentEventTypeCode = &equipmentEventTypeCode
	return r
}

// Maximum number of items to return.
func (r ApiEventsGetRequest) Limit(limit int32) ApiEventsGetRequest {
	r.limit = &limit
	return r
}

// A server generated value to specify a specific point in a collection result, used for pagination.  The current, previous, next, first and last pages are available in the response headers.  For the initial request to the service, this parameter should be null or 1.
func (r ApiEventsGetRequest) Cursor(cursor string) ApiEventsGetRequest {
	r.cursor = &cursor
	return r
}

// An API-Version header MAY be added to the request (optional); if added it MUST only contain MAJOR version. API-Version header MUST be aligned with the URI version.
func (r ApiEventsGetRequest) APIVersion(aPIVersion string) ApiEventsGetRequest {
	r.aPIVersion = &aPIVersion
	return r
}

func (r ApiEventsGetRequest) Execute() (*Events, *http.Response, error) {
	return r.ApiService.EventsGetExecute(r)
}

/*
EventsGet Find events.

Returns all events filtered by the queryParameters.  This endpoint requires **at least one** of the following input parameters:

* carrierBookingReference
* transportDocumentReference
* equipmentReference

Note:  It is possible to combine queryParameters. When combining queryParameters be aware that it is also possible to make combinations that are mutually contradicting.\
For example, shipmentEventTypeCode=DRFT and equipmentEventTypeCode=GTIN; since there is no event that can be a ShipmentEvent and an EquipmentEvent at the same time this will return an empty list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEventsGetRequest
*/
func (a *EventsApiService) EventsGet(ctx context.Context) ApiEventsGetRequest {
	return ApiEventsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Events
func (a *EventsApiService) EventsGetExecute(r ApiEventsGetRequest) (*Events, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Events
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventsApiService.EventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrierBookingReference != nil {
		localVarQueryParams.Add("carrierBookingReference", parameterToString(*r.carrierBookingReference, ""))
	}
	if r.transportDocumentReference != nil {
		localVarQueryParams.Add("transportDocumentReference", parameterToString(*r.transportDocumentReference, ""))
	}
	if r.equipmentReference != nil {
		localVarQueryParams.Add("equipmentReference", parameterToString(*r.equipmentReference, ""))
	}
	if r.eventType != nil {
		localVarQueryParams.Add("eventType", parameterToString(*r.eventType, "csv"))
	}
	if r.eventCreatedDateTime != nil {
		localVarQueryParams.Add("eventCreatedDateTime", parameterToString(*r.eventCreatedDateTime, ""))
	}
	if r.shipmentEventTypeCode != nil {
		localVarQueryParams.Add("shipmentEventTypeCode", parameterToString(*r.shipmentEventTypeCode, "csv"))
	}
	if r.transportEventTypeCode != nil {
		localVarQueryParams.Add("transportEventTypeCode", parameterToString(*r.transportEventTypeCode, "csv"))
	}
	if r.equipmentEventTypeCode != nil {
		localVarQueryParams.Add("equipmentEventTypeCode", parameterToString(*r.equipmentEventTypeCode, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/stream+json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.aPIVersion != nil {
		localVarHeaderParams["API-Version"] = parameterToString(*r.aPIVersion, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Consumer-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
